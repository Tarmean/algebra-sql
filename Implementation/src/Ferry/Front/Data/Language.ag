{
module Ferry.Front.Data.Language where
    
import Ferry.Front.Data.Meta

type Identifier = String

data Const = CInt Integer
           | CFloat Double
           | CBool Bool
           | CString String
    deriving (Show, Eq)
}

data Op
    | Op  m::{Meta} s::String

data Expr
    | UnOp         m::{Meta} o::Op e::Expr
    | BinOp        m::{Meta} o::Op e1::Expr e2::Expr
    | Const        m::{Meta} c::Const
    | Var          m::{Meta} x::Identifier
--    | PrimFn       m::{Meta} f::String
    | Abstr        m::{Meta} x::Pattern e::Expr
    | App          m::{Meta} e1::Expr e2::Expr
    | If           m::{Meta} e1::Expr e2::Expr e3::Expr
    | Record       m::{Meta} els::RecElems
    | Paren        m::{Meta} e::Expr
    | List         m::{Meta} es::Exprs
    | Elem         m::{Meta} e::Expr i::{Either String Integer}
    | Let          m::{Meta} bs::Bindings e::Expr
    | Table        m::{Meta} n::String cs::Columns ks::Keys
    | Relationship m::{Meta} a1::Cardinality e1::Expr a2::Cardinality e2::Expr k1::Key k2::Key
--    | For          m::{Meta} p::Pattern e1::Expr bd::ForElems er::Expr
    | QComp        m::{Meta} q::QCompr
    
data QCompr
    | FerryCompr   m::{Meta} p::Pattern e1::Expr bd::ComprElems er::Expr
    | LINQCompr    m::{Meta} p::Pattern e1::Expr b::LINQBody
    | HaskellCompr m::{Meta}
    
data LINQBody 
    | LINQBody     m::{Meta} bd::ComprElems r::LINQResult c::MaybeContinuation
    
data Continuation 
    | Continuation m::{Meta} p::Pattern b::LINQBody

data ComprElem
    | CLet   m::{Meta} p::Pattern e::Expr
    | CWhere m::{Meta} e::Expr
    | CGroup m::{Meta} es::Exprs
    | COrder m::{Meta} es::ExprOrders
    | CFrom  m::{Meta} p::Pattern e::Expr

data LINQResult
    | Select m::{Meta} e::Expr
    | GroupBy m::{Meta} e1::Expr e2::Expr
    | GroupWith m::{Meta} e1::Expr e2::Expr

data ExprOrder
    | ExprOrder m::{Meta} e::Expr o::Order

data Pattern
    | PVar  m::{Meta} x::String
    | PPat  m::{Meta} xs::{[String]}

data Order
    | Ascending m::{Meta}
    | Descending m::{Meta}
    
data Cardinality
    | One m::{Meta}
    | Many m::{Meta}

data Key
    | Key m::{Meta} s::{[String]}

data Column
    | Column m::{Meta} n::String t::Type

data Binding
    | Binding m::{Meta} x::String e::Expr

data RecElem
    | TrueRec m::{Meta} i::String e::Expr
    | TuplRec m::{Meta} i::Int    e::Expr

type RecElems = [RecElem]
type Exprs = [Expr]
type Bindings = [Binding]
type Columns = [Column]
type Keys = [Key]
type ExprOrders = [ExprOrder]
type ComprElems = [ComprElem]
type MaybeContinuation = (Maybe Continuation)

deriving Continuation Op Expr ComprElem ExprOrder Pattern Order Cardinality Key Column Binding RecElem Type QCompr LINQBody LINQResult : Show, Eq

data Type
    | TInt m::{Meta}
    | TFloat m::{Meta}
    | TString m::{Meta}
    | TBool m::{Meta} 
{   
instance HasMeta Expr where              
    getMeta (UnOp         m _ _)         = m
    getMeta (BinOp        m _ _ _)       = m
    getMeta (Const        m _)           = m
    getMeta (Var          m _)           = m
--    getMeta (PrimFn       m _)           = m
    getMeta (Abstr        m _ _)         = m
    getMeta (App          m _ _)         = m
    getMeta (If           m _ _ _)       = m
    getMeta (Record       m _)           = m
    getMeta (Paren        m _)           = m
    getMeta (List         m _)           = m
    getMeta (Elem         m _ _)         = m
    getMeta (Let          m _ _)         = m
    getMeta (Table        m _ _ _)       = m
    getMeta (Relationship m _ _ _ _ _ _) = m 
    getMeta (QComp        m _)           = m
--    getMeta (For          m _ _ _ _)     = m

instance HasMeta QCompr where
    getMeta (FerryCompr m _ _ _ _) = m
    getMeta (LINQCompr m _ _ _)  = m
    getMeta (HaskellCompr m)       = m
}                                        