{
module Ferry.Front.Render.PrettyFerry where

import Ferry.Front.Data.Base
import Ferry.Front.Data.Meta
import Ferry.Front.Data.Instances
    
}

include "Ferry/Front/Data/AST.ag"

attr Expr RecElems RecElem syn pretty :: {String}

sem Expr
    | UnOp   lhs.pretty = @o.pretty ++ " " ++ @e.pretty
    | BinOp  lhs.pretty = @e1.pretty ++ " " ++ @o.pretty ++ " " ++ @e2.pretty
    | Const  lhs.pretty = pretty @c
    | Var    lhs.pretty = @x
    | Abstr  lhs.pretty = "(" ++ @x.pretty ++ "->" ++ @e.pretty ++ ")"
    | App    lhs.pretty = @e1.pretty ++ " " ++ @e2.pretty
    | If     lhs.pretty = "if " ++ @e1.pretty ++ " then " ++ @e2.pretty ++ " else " ++ @e3.pretty
    | Record @els.first = True
             lhs.pretty = case head @els of
                            (TrueRec _ _ _) -> "{" ++ @els.pretty ++ "}"
                            (TuplRec _ _ _) -> "(" ++ @els.pretty ++ ")"
    | Paren  lhs.pretty = "(" ++ @e.pretty ++ ")"
    | List   es.first   = True
             lhs.pretty = "[" ++ @es.pretty ++ "]"
    | 

attr RecElems Exprs inh first :: Bool
      
sem RecElems
    | Cons tl.first = False
           lhs.pretty = if (@lhs.pretty) 
                            then @hd.pretty ++ @tl.pretty
                            else ", " ++ @hd.pretty ++ @tl.pretty
    | Nil  lhs.pretty = ""

sem RecElem
    | TrueRec lhs.pretty = @i ++ " = " ++ @e.pretty
    | TuplRec lhs.pretty = @e.pretty 
    
sem Expr
   | Cons tl.first = False
          lhs.pretty = if (@lhs.pretty) 
                           then @hd.pretty ++ @tl.pretty
                           else ", " ++ @hd.pretty ++ @tl.pretty
   | Nil  lhs.pretty = ""