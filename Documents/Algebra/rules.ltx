\section{Algebraic compilation}

\begin{infrules}
     \infrule[ac-int]%
        {| |}%
        {|Gam, loop +- c => (attach pos 1 (attach item1 c loop), {item1}, empty)|}\\
    \infrule[ac-Binop]%
        {|Gam, loop +- e1 => (q1, {item1}, empty)|\quad%
         |Gam, loop +- e2 => (q2, {item1}, empty)|}
        {|Gam, loop +- e1 op e2 => (proj (iter, pos, item1:res) (oper res item1 item1' (join (iter1:iter1') q1 ((proj (iter':iter, item1':item1) q2)))) , {item1}, empty)|}\\
    \infrule[ac-let]
        {| Gam, loop +- e1 => (q1, cs1, ts1)|\quad%
         | Gam[x +-> (q1, cs1, ts1)], loop +- e2 => (q2, cs2, ts2)|}
        {| Gam, loop +- let x = e1 in e2 => (q2, cs2, ts2)|}\\
    \infrule[ac-var]
        {| Gam(x) = (q, cs, ts)|}
        {| Gam, loop +- x => (q, cs, ts)|}\\
    \infrule[ac-rec]
        {| Gam, loop +- ei => (qi, csi, tsi)|\quad |i = 1, 2 |\quad%
         | cs2' = incr cs2 (card cs1) |\\
         | q = proj (iter, pos, ln cs1, ln cs2)(join (iter1:iter1') q1 (proj (iter':iter, ln cs2': ln cs2) q2))|}
        {| Gam, loop +- {x1 = e1, x2 = e2} => (q, {x1 -> cs1, x2 -> cs2'}, empty)|}\\
    \infrule[ac-lookup]
        {| Gam, loop +- e => (q1, cs@{..., l -> csl, ...}, ts)|\quad%
         | csl' = decr csl |\\
         | q = proj (iter, pos, ln csl': ln csl) q1 |}
        {| Gam, loop +- e.l => (q, csl', empty)|}\\
    \infrule[ac-Cons]
        {| Gam, loop +- ei => (qi, csi, empty) where i = 1,2|\\
         | q = proj (iter, pos:pos', ln cs1) (rank pos' (<ord,pos>) (union (attach ord 1 q1) (attach ord 2 q2))) |}
        {| Gam, loop +- Cons e1 e2 => (q, cs1, empty)|}\\
    \infrule[ac-Nil]
        {| cs = tyToCol t 1|}
        {| Gam, loop +- Nil :: t => (EmptyTBL (iter, pos, ln cs), cs, empty)|}\\
    \infrule[ac-Table]
        {| q = (cross loop (rank pos (<||k1||>) (Table t (x1, ..., xn) (i1, ..., itn) (||k1||, ..., ||km||))))|}
        {| Gam, loop +- table t (x1 t1, ..., xn tn) with keys (k1, ..., km) => (q, {x1 -> {i1}, ... xn -> {itn}}, empty)|}\\
    \infrule[ac-If]
        {| Gam, loop +- e1 => (q1, {item1}, empty)|\\
         | loopthen = proj iter (sel item1 q1) | \quad | Gamthen = map (\qm -> join iter qm loopthen) Gam |\\
         | loopelse = proj iter (sel item1 (not (item1:item1) q1))| \quad | Gamelse = map (\qm -> join iter qm loopelse) Gam |\\
         | Gamthen, loopthen +- e2 => (q2, cs2, empty)|\quad |Gamelse, loopelse +- e3 => (q3, cs3, empty) |\\
         | q = proj (iter, pos ln cs2) (union (attach ord 1 q2) (attach ord 2 q3))|}
        {| Gam, loop +- if e1 then e2 else e3 => (q, cs2, empty)|}\\
    \infrule[ac-map]
        {| Gam, loop +- e1 => (q1, cs1, empty) |\quad | qv' = rownum iter' (iter, pos) q1|\\
         | qv = proj (iter:iter', pos:pos', ln(cs1)) (attach pos' 1 qv')|\\
         | loopv = proj (iter:iter') qv'| \quad |mapv = proj (outer:iter, inner:iter', pos':pos) qv'|\\
         | Gamv = map (\(x, (q, cs, ts)) -> (x, (proj (iter:inner, pos, ln cs) (join (iter:outer) q mapv), cs ts))) Gam|\\
         | Gamv[x +-> qv, cs1, ts1], loopv +- e2 => (q2, cs2, ts2)|\\
         | q = proj (iter:outer, pos:pos', ln cs2) (join (iter:inner) q2 mapv) |}
        {| Gam, loop +- map (\x -> e2) e1 => (q, cs2, empty)|}
\end{infrules}
\begin{code}
tyToCol :: Type -> Int -> Columns
\end{code}

Optimized lists, these rules can replace the ac-Cons rule from the previous section.
ac-Cons1 and ac-ConsNil1 have the same signature as ac-Cons. ac-ConsNil1 checks for a singleton list
if so no expensive attach unions and projects have to be carried out.
ac-Cons1 adds an extra environment element to the for transforming e2, this optimized version carries
out the rank operator. The rules that fit, ac-Cons2, and ac-ConsNil2 only do the attach but do not perform the
rank, or the projection. These will only be done by the first element of the list.

\begin{infrules}
    \infrule[ac-Cons1]
            {| Gam, loop +- e1 => (q1, cs1, empty) |\quad
             | Gam, loop, 2 +- e2 => (q2, cs2, empty)|\\
             | q = proj (iter, pos:pos', ln cs1) (rank pos' (<ord,pos>) (union (attach ord 1 q1) q2))|}
            {| Gam, loop +- Cons e1 e2 => (q, cs1, empty)|}\\
    \infrule[ac-ConsNil1]
            {| Gam, loop +- e1 => (q1, cs1, empty)|}
            {| Gam, loop +- Cons e1 Nil => (q1, cs1, empty)|}\\
    \infrule[ac-Cons2]
            {| Gam, loop +- e1 => (q1, cs1, empty) |\quad
             | Gam, loop, i + 1 +- e2 => (q2, cs2, empty) |\quad
             | q = union (attach ord i q1) q2 |}
            {| Gam, loop, i +- Cons e1 e2 => (q, cs1, empty) |}\\
    \infrule[ac-ConsNil2]
            {| Gam, loop +- e1 => (q1, cs1, empty)|\quad
             | q = (attach ord i q1) |}
            {| Gam, loop, i +- Cons e1 Nil => (q, cs1, empty) |}
\end{infrules}