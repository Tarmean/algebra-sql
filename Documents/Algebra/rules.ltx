\section{Algebraic compilation}

\begin{infrules}
     \infrule[ac-int]%
        {| |}%
        {|Gam, loop +- c => (attach pos 1 (attach item1 c loop), {item1}, empty)|}\\
    \infrule[ac-Binop]%
        {|Gam, loop +- e1 => (q1, {item1}, empty)|\quad%
         |Gam, loop +- e2 => (q2, {item1}, empty)|}
        {|Gam, loop +- e1 op e2 => (proj (iter, pos, item1:res) (oper res item1 item1' (join (iter1:iter1') q1 ((proj (iter':iter, item1':item1) q2)))) , {item1}, empty)|}\\
    \infrule[ac-let]
        {| Gam, loop +- e1 => (q1, cs1, ts1)|\quad%
         | Gam[x +-> (q1, cs1, ts1)], loop +- e2 => (q2, cs2, ts2)|}
        {| Gam, loop +- let x = e1 in e2 => (q2, cs2, ts2)|}\\
    \infrule[ac-var]
        {| Gam(x) = (q, cs, ts)|}
        {| Gam, loop +- x => (q, cs, ts)|}\\
    \infrule[ac-rec]
        {| Gam, loop +- ei => (qi, csi, tsi)|\quad |i = 1, 2 |\quad%
         | cs2' = incr cs2 (card cs1) |\quad%
         | ts = ts1 ++ (incr ts2 (card cs1))|\\
         | q = proj (iter, pos, ln cs1, ln cs2)(join (iter1:iter1') q1 (proj (iter':iter, ln cs2': ln cs2) q2))|}
        {| Gam, loop +- {x1 = e1, x2 = e2} => (q, {x1 -> cs1, x2 -> cs2'}, ts)|}\\
    \infrule[ac-lookup]
        {| Gam, loop +- e => (q1, cs@{..., l -> csl, ...}, ts)|\quad%
         | (csl', i) = decr csl |\quad
         | ts = {l +-> ts!(l + i) || l elem ln csl'} | \\
         | q = proj (iter, pos, ln csl': ln csl) q1 |}
        {| Gam, loop +- e.l => (q, csl', empty)|}\\
    \infrule[ac-Cons]
        {| Gam, loop +- ei => (qi, csi, empty) where i = 1,2|\\
         | ks = keys ts1 |\quad | cols = cs cs1 |\\
         | q' = rownum iter' (iter,ord,pos) (rank pos' (<ord,pos>) (union (attach ord 1 q1) (attach ord 2 q2))) |\\
         | q = proj (iter, pos:pos', cols \\ ks, ks:iter') q'|\quad | qr = proj (ord, iter', cols) q'|}
        {| Gam, loop +- Cons e1 e2 => (q, cs1, merge qr ts1 ts2)|}\\
    \infrule[ac-Nil]
        {| cs = tyToCol t 1|}
        {| Gam, loop +- Nil :: [t] => (EmptyTBL (iter, pos, ln cs), cs, empty)|}\\
    \infrule[ac-Table]
        {| q = (cross loop (rank pos (<||k1||>) (Table t (x1, ..., xn) (i1, ..., itn) (||k1||, ..., ||km||))))|}
        {| Gam, loop +- table t (x1 t1, ..., xn tn) with keys (k1, ..., km) => (q, {x1 -> {i1}, ... xn -> {itn}}, empty)|}\\
    \infrule[ac-If]
        {| Gam, loop +- e1 => (q1, {item1}, empty)|\\
         | loopthen = proj iter (sel item1 q1) | \quad | Gamthen = map (\qm -> join iter qm loopthen) Gam |\\
         | loopelse = proj iter (sel item1 (not (item1:item1) q1))| \quad | Gamelse = map (\qm -> join iter qm loopelse) Gam |\\
         | Gamthen, loopthen +- e2 => (q2, cs2, ts2)|\quad |Gamelse, loopelse +- e3 => (q3, cs3, ts3) |\\
         | ks = keys ts2| \quad | cols = ln cs2 | \\
         | q' = rownum iter' (iter, ord, pos) (union (attach ord 1 q2) (attach ord 2 q3)) |\\
         | q = proj (iter, pos cols \\ ks, ks:iter') q'|}
        {| Gam, loop +- if e1 then e2 else e3 => (q, cs2, merge q' ts2 ts3)|}\\
    \infrule[ac-map]
        {| Gam, loop +- e1 => (q1, cs1, ts1) |\quad
         | (qv', qv, mapv, loopv, Gamv) = mapForward Gam q1 cs1 |\\ 
         | Gamv[x +-> (qv, cs1, ts1)], loopv +- e2 => (q2, cs2, ts2)|\\
         | q = proj (iter:outer, pos:pos', ln cs2) (join (iter:inner) q2 mapv) |}
        {| Gam, loop +- map (\x -> e2) e1 => (q, cs2, ts2)|}\\
    \infrule[ac-filter]
        {| Gam, loop +- e1 => (q1, cs1, ts1) | \quad
         | (qv', qv, mapv, loopv, Gamv) = mapForward Gam q1 cs1 |\\ 
         | Gamv[x +-> (qv, cs1, ts1)], loopv +- e2 => (q2, {item1}, empty) |\\
         | q = proj (iter, pos, ln cs1) (sel res (join (inner:iter') qv' (proj (iter':iter, res:item1) q2)))|}
        {| Gam, loop +- filter (\x -> e2) e1 => (q, cs1, ts1)|} \\
    \infrule[ac-nub]
        {| Gam, loop +- e => (q, cs, ts) |\\
         | q' = proj (iter, pos, ln cs) (join (pos:pos', iter:iter') q (aggr (pos':min pos/p', iter':min iter/p') (rowrank p' (<iter, ln cs>) q))) |}
        {| Gam, loop +- nub e => (q', cs, ts) |}\\
    \infrule[ac-the]
        {| Gam, loop +- e => (q, cs, ts) |\\
         | q' = attach one 1 (rownum' pos (ln cs) iter (distinct (proj (iter, ln cs) q))) |\\
         | qr = proj (iter, pos, ln cs) (sel res (eq res pos one q'))|}
        {| Gam, loop +- the e => (qr, cs, ts) |}\\
    \infrule[ac-length]
        {| Gam, loop +- e => (q, cs, ts) |\\
         | q' = attach pos 1 (agrr (item1:max(item1)/iter) (union (attach item1 0 loop) (aggr (item1:count/iter) q))) |}
        {| Gam, loop +- length e => (q', {item1}, empty) |}\\
    \infrule[ac-Box]
        {| Gam, loop +- e => (q, cs, ts) |\quad
         | q' = attach pos 1 (proj (iter, item1:iter) loop) |}
        {| Gam, loop +- box e => (q', {item1}, {item1 ->  (q, cs, ts)}) |} \\
    \infrule[ac-unBox]
        {| Gam, loop +- e => (q, {item1}, ts) |\quad
         | (q', cs', ts') = lookup item1 ts |\\
         | q'' = proj (iter:iter', pos, ln cs')(join (item1':iter) (proj (iter':iter, item1':item1) q) q')|}
        {| Gam, loop +- unbox e => (q'', cs', ts') |}\\
    \infrule[ac-zip]
        {| Gam, loop +- e1 => (q1, cs1, ts1) |\quad
         | Gam, loop +- e2 => (q2, cs2, ts2) |\\
         | q1' = abspos q1 cs1 | \quad | q2' = abspos q2 cs2 |\\
         | cs2' = incr cs2 (card cs1) |\\
         | q = proj (iter, pos, ln cs, ln cs2') (join (iter:iter', pos:pos') q1' (proj (iter':iter, pos':pos, ln cs2':ln cs2) q2'))|\\
         | cs = {1 +-> cs1, 2 +-> cs2'}|\quad | ts = ts ++ ts2'|}
        {| Gam, loop +- zip e1 e2 => (q, cs, ts)|}\\
    \infrule[ac-unzip]
        {| Gam, loop +- e1 => (q, {1 -> cs1, 2 -> cs2}, ts)|\\
         | q' = proj (iter, pos, item1:iter, item2:iter) (attach pos 1 loop)|\\
         | q1 = proj (iter, pos, ln cs1) q|\\
         | q2 = proj (iter, pos, ln (decr cs2):ln cs2) q|\\
         | ts = {1 -> (q1, cs1, {i -> ts!i || i elem cs1, i elem ts}), 2 -> (q2, decr cs2, decr {i -> ts!i || i elem cs2, i elem ts}) }|}
        {| Gam, loop +- unzip e1 => (q', {1 -> item1, 2 -> item2}, ts)|}\\
    \infrule[ac-head]
        {| Gam, loop +- e1 => (q1', cs1, ts1)| \quad | q1 = absPos q1'|\\
         | q = posSel 1 iter q1 |}
        {| Gam, loop +- head e1 => (q, cs1, ts1) |}\\
    \infrule[ac-tail]
        {| Gam, loop +- e1 => (q1', cs1, ts1)| \quad | q1 = absPos q1'|\\
         | q = proj (iter, pos, ln cs1) (sel res (gt res pos one (attach one 1 q1))) |}
        {| Gam, loop +- tail e1 => (q, cs1, ts1) |}\\
    \infrule[ac-concat]
        {| Gam, loop +- e1 => (q1, {item1}, {1 +-> (qs, css, tss)}) |\\
         | q = proj (iter:iter', pos:pos'', ln css) (rank (pos'') (<pos', pos>) (join (item1':iter) (proj (iter':iter, pos':pos, item1':item1) q1) qs)) |}
        {| Gam, loop +- concat e1 => (q, css, tss)|}\\
    \infrule[ac-and]
        {| Gam, loop +- e1 => (q1, cs1, ts1)|\\
         | q = attach pos 1 (proj (iter, item1) (aggr (item1:min(item1)/iter) (union q1 (attach pos 1 (attach item1 True loop)))))|}
        {| Gam, loop +- and e1 => (q, cs1, empty)|}\\
    \infrule[ac-or]
        {| Gam, loop +- e1 => (q1, cs1, ts1)|\\
         | q = attach pos 1 (proj (iter, item1) (aggr (item1:max(item1)/iter) (union q1 (attach pos 1 (attach item1 False loop)))))|}
        {| Gam, loop +- and e1 => (q, cs1, empty)|}\\
    \infrule[ac-length]
        {| Gam, loop +- e1 (q1, cs1, ts1)|\\
         | q = attach pos 1 (proj (iter, item1) (aggr (item1:max(item1)/iter) (union (attach item1 0 loop) (aggr (item1:count/iter) q1))))|}
        {| Gam, loop +- length e1 => (q, {item1}, empty)|}\\
    \infrule[ac-groupWith]
        {| Gam, loop +- e3 => (q3, cs3, ts3) |\\
         | (qv', qv, map', loop', Gam') = mapForward Gam q3 cs3 |\\
         | Gam'[x1 +-> (qv, cs3, ts3)], loop' +- e1 => (q1, cs1, ts1) |\\
         | Gam'[x2 +-> (qv, cs3, ts3)], loop' +- e2 => (q2, cs2, ts2) |\\
         | cs2' = incr cs2 (card cs1) |\\
         | q = rowrank gk (iter, ln cs2') (join (inner:iter') ((proj (iter, pos, inner) qv)) ((join (iter'':iter') ((proj (iter'':iter, ln cs1) q1)) ((proj (iter':iter, ln cs2' : ln cs2) q2)))))|\\
         | qout = distinct (proj (iter, pos:gk, ln cs2 : ln cs2', item':gk) q)|\\
         | qin = proj (iter:gk, pos, ln cs1) q|}
        {| Gam, loop +- groupWith (\x1 -> e1) (\x2 -> e2) e3 => (qout, {1 +-> cs2, 2 +-> item'}, {item' +-> (qin, cs1, ts1)}) |}\\
    \infrule[ac-groupBy]
        {| Gam, loop +- e3 => (q3, cs3, ts3) |\\
         | (qv', qv, map', loop', Gam') = mapForward Gam q3 cs3 |\\
         | Gam'[x1 +-> (qv, cs3, ts3)], loop' +- e1 => (q1, cs1, ts1)|\\
         | Gam'[x2 +-> (qv, cs3, ts3)], loop' +- e2 => (q2, cs2, ts2)|\\
         | cs2' = incr cs2 (card cs1) |\\
         | q = rowrank gk (iter, ln cs2') (join (inner:iter') ((proj (iter, pos, inner) qv)) ((join (iter'':iter') ((proj (iter'':iter, ln cs1) q1)) ((proj (iter':iter, ln cs2' : ln cs2) q2))))) |\\
         | n = length cs1 |\\
         | qout = distinct (proj (iter, pos:gk, item1:gk, ..., itemn:gk) q)|\\
         | cs = { n -> i || (n -> _, i) <- zip cs1 [1..]} |\\
         | csi = lookup cs1 i | \quad | where i elem [1..n] | \\ 
         | qi = proj (iter:gk, decr csi:csi, pos) q | \quad | where i elem [1..n] |\\
         | tsi = { n -> ts1!o || (o, n) <- zip (ln csi) (ln $ decr csi) } | \quad | where i elem [1..n]|\\ 
         | ts = { i ->  (qi, decr csi, tsi) || i <- [1..n]} |}
        {| Gam, loop +- groupBy (\x1 -> e1) (\x2 -> e2) e3 => (qout, cs, ts)|}\\
    \infrule[ac-sum]
        {| Gam, loop +- e1 => (q, {item1}, empty)|\\
         | q' = attach pos 1 (aggr (item1:max(item)/iter) (union (attach item1 0 loop) (proj (iter, item1) (aggr (item1:sum(item1)/iter) q))))|}
        {| Gam, loop +- sum e1 => (q', {item1}, empty)|}
    \end{infrules}
\begin{code}
tyToCol :: Type -> Int -> Columns

absPos :: Query -> Columns -> Query
absPos q cs = proj (iter, pos, ln cs) (rownum' pos pos' iter (proj (iter:iter, pos':pos, ln cs) q))

mapForward :: Gam -> Query -> Cs -> (Query, Query, Query, Query, Gam)
mapForward Gam q cs =  let  qv'    = rownum inner (iter, pos) q
                            qv     = proj (iter:inner, pos:pos', ln cs) (attach pos' 1 qv')
                            mapv   = proj (outer:iter, inner, pos':pos) qv'
                            loopv  = proj (iter:inner) qv'
                            Gamv   = map (\(x, (q, cs, ts)) -> (x, (proj (iter:inner, pos, ln cs) (join (iter:outer) q mapv), cs ts))) Gam
                        in  (qv', qv, mapv, loopv, Gamv)
                        
merge qo ts1' ts2' =  {  x1 +-> (q', cs1, merge qr ts1 ts2)  
                      |  x1 +-> (q1, cs1, ts1) elem ts1'
                      ,  x2 +-> (q2, cs2, ts2) elem ts2'
                      ,  x1 == x2 
                      ,  let  ks    = keys ts1
                              cols  = ln cs1
                              qo'   = join (ord, old:iter) ((proj (ord, iterR:iter', old:itemx) qo)) ((union (attach ord 1 q1) (attach ord 2 q2)))
                              q     = rownum iter' (iter, ord, pos) (proj (iter, ord, pos, cols) qo')
                              qr    = proj (iter', ord, cols ) q
                              q'    = proj (iter:iterR, pos, cols \\ ks, ks:iter') q}
\end{code}

Optimized lists, these rules can replace the ac-Cons rule from the previous section.
ac-Cons1 and ac-ConsNil1 have the same signature as ac-Cons. ac-ConsNil1 checks for a singleton list
if so no expensive attach unions and projects have to be carried out.
ac-Cons1 adds an extra environment element to the for transforming e2, this optimized version carries
out the rank operator. The rules that fit, ac-Cons2, and ac-ConsNil2 only do the attach but do not perform the
rank, or the projection. These will only be done by the first element of the list.

\begin{code}
merges n ts1' ts2'   =  {  x1 -> (q, cs1, merges n ts1 ts2)
                        |  x1 -> (q1, cs1, ts1) elem ts1'
                        ,  x2 -> (q2, cs2, ts2) elem ts2'
                        ,  x1 == x2
                        ,  let  q = union (attach ord n q1) q2 }
mergen n ts1'        =  {  x1 -> (q, cs1, mergen n ts1)
                        |  x1 -> (q1, cs1, ts1) elem ts1'
                        ,  let  q = attach ord n q1 }
mergef qo ts1' ts2'  =  {  x1 -> (q', cs1, mergef qr ts1 ts2)
                        |  x1 -> (q1, cs1, ts1) elem ts1'
                        ,  x2 -> (q2, cs2, ts2) elem ts2'
                        ,  x1 == x2
                        ,  let  ks    = keys ts1
                                cols  = ln cs1
                                qo'   = join (ord, old:iter) ((proj (ord, iterR:iter', old:itemx) qo)) ((rownum iter' (iter, ord, pos) (union (attach ord 1 q1) q2)))
                                q     = proj (iter, ord, pos, cols) qo'
                                qr    = proj (iter', ord, cols) q
                                q'    = proj (iter:iterR, pos, cols\\ks, ks:iter') q}
\end{code}

\begin{infrules}
    \infrule[ac-Cons1]
            {| Gam, loop +- e1 => (q1, cs1, empty) |\quad
             | Gam, loop, 2 +- e2 => (q2, cs2, empty)|\\
             | q' = rownum iter' (iter,ord,pos) (rank pos' (<ord, pos>) (union (attach ord 1 q1) q2))| \\
             | q = proj (iter, pos:pos', cols\\ks, ks:iter') q'|}
            {| Gam, loop +- Cons e1 e2 => (q, cs1, mergef q' ts1 ts2)|}\\
    \infrule[ac-ConsNil1]
            {| Gam, loop +- e1 => (q1, cs1, empty)|}
            {| Gam, loop +- Cons e1 Nil => (q1, cs1, empty)|}\\
    \infrule[ac-Cons2]
            {| Gam, loop +- e1 => (q1, cs1, empty) |\quad
             | Gam, loop, i + 1 +- e2 => (q2, cs2, empty) |\\
             | q = union (attach ord i q1) q2 |}
            {| Gam, loop, i +- Cons e1 e2 => (q, cs1, merges i ts1 ts2) |}\\
    \infrule[ac-ConsNil2]
            {| Gam, loop +- e1 => (q1, cs1, empty)|\quad
             | q = (attach ord i q1) |}
            {| Gam, loop, i +- Cons e1 Nil => (q, cs1, mergen n ts1) |}
\end{infrules}