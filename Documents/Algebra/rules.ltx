\section{Algebraic compilation}

\begin{infrules}
     \infrule[ac-int]%
        {| |}%
        {|Gam, loop +- c => (attach pos 1 (attach item1 c loop), {item1}, empty)|}\\
    \infrule[ac-Binop]%
        {|Gam, loop +- e1 => (q1, {item1}, empty)|\quad%
         |Gam, loop +- e2 => (q2, {item1}, empty)|}
        {|Gam, loop +- e1 op e2 => (proj (iter, pos, item1:res) (oper res item1 item1' (join (iter1:iter1') q1 ((proj (iter':iter, item1':item1) q2)))) , {item1}, empty)|}\\
    \infrule[ac-let]
        {| Gam, loop +- e1 => (q1, cs1, ts1)|\quad%
         | Gam[x +-> (q1, cs1, ts1)], loop +- e2 => (q2, cs2, ts2)|}
        {| Gam, loop +- let x = e1 in e2 => (q2, cs2, ts2)|}\\
    \infrule[ac-var]
        {| Gam(x) = (q, cs, ts)|}
        {| Gam, loop +- x => (q, cs, ts)|}\\
    \infrule[ac-rec]
        {| Gam, loop +- ei => (qi, csi, tsi)|\quad |i = 1, 2 |\quad%
         | cs2' = incr cs2 (card cs1) |\quad%
         | ts = ts1 ++ (incr ts2 (card cs1))|\\
         | q = proj (iter, pos, ln cs1, ln cs2)(join (iter1:iter1') q1 (proj (iter':iter, ln cs2': ln cs2) q2))|}
        {| Gam, loop +- {x1 = e1, x2 = e2} => (q, {x1 -> cs1, x2 -> cs2'}, ts)|}\\
    \infrule[ac-lookup]
        {| Gam, loop +- e => (q1, cs@{..., l -> csl, ...}, ts)|\quad%
         | (csl', i) = decr csl |\quad
         | ts = {l +-> ts!(l + i) || l elem ln csl'} | \\
         | q = proj (iter, pos, ln csl': ln csl) q1 |}
        {| Gam, loop +- e.l => (q, csl', empty)|}\\
    \infrule[ac-Cons]
        {| Gam, loop +- ei => (qi, csi, empty) where i = 1,2|\\
         | ks = keys ts1 |\quad | cols = cs cs1 |\\
         | q' = rownum iter' (iter,ord,pos) (rank pos' (<ord,pos>) (union (attach ord 1 q1) (attach ord 2 q2))) |\\
         | q = proj (iter, pos:pos', cols \\ ks, ks:iter') q'|\quad | qr = proj (ord, iter', cols) q'|}
        {| Gam, loop +- Cons e1 e2 => (q, cs1, merge qr ts1 ts2)|}\\
    \infrule[ac-Nil]
        {| cs = tyToCol t 1|}
        {| Gam, loop +- Nil :: t => (EmptyTBL (iter, pos, ln cs), cs, empty)|}\\
    \infrule[ac-Table]
        {| q = (cross loop (rank pos (<||k1||>) (Table t (x1, ..., xn) (i1, ..., itn) (||k1||, ..., ||km||))))|}
        {| Gam, loop +- table t (x1 t1, ..., xn tn) with keys (k1, ..., km) => (q, {x1 -> {i1}, ... xn -> {itn}}, empty)|}\\
    \infrule[ac-If]
        {| Gam, loop +- e1 => (q1, {item1}, empty)|\\
         | loopthen = proj iter (sel item1 q1) | \quad | Gamthen = map (\qm -> join iter qm loopthen) Gam |\\
         | loopelse = proj iter (sel item1 (not (item1:item1) q1))| \quad | Gamelse = map (\qm -> join iter qm loopelse) Gam |\\
         | Gamthen, loopthen +- e2 => (q2, cs2, ts2)|\quad |Gamelse, loopelse +- e3 => (q3, cs3, ts3) |\\
         | ks = keys ts2| \quad | cols = ln cs2 | \\
         | q' = rownum iter' (iter, ord, pos) (union (attach ord 1 q2) (attach ord 2 q3)) |\\
         | q = proj (iter, pos cols \\ ks, ks:iter') q'|}
        {| Gam, loop +- if e1 then e2 else e3 => (q, cs2, merge q' ts2 ts3)|}\\
    \infrule[ac-map]
        {| Gam, loop +- e1 => (q1, cs1, ts1) |\quad
         | (qv', qv, mapv, loopv, Gamv) = mapForward Gam q1 cs1 |\\ 
         | Gamv[x +-> (qv, cs1, ts1)], loopv +- e2 => (q2, cs2, ts2)|\\
         | q = proj (iter:outer, pos:pos', ln cs2) (join (iter:inner) q2 mapv) |}
        {| Gam, loop +- map (\x -> e2) e1 => (q, cs2, ts2)|}\\
    \infrule[ac-filter]
        {| Gam, loop +- e1 => (q1, cs1, ts1) | \quad
         | (qv', qv, mapv, loopv, Gamv) = mapForward Gam q1 cs1 |\\ 
         | Gamv[x +-> (qv, cs1, ts1)], loopv +- e2 => (q2, {item1}, empty) |\\
         | q = proj (iter, pos, ln cs1) (sel res (join (inner:iter') qv' (proj (iter':iter, res:item1) q2)))|}
        {| Gam, loop +- filter (\x -> e2) e1 => (q, cs1, ts1)|} \\
    \infrule[ac-Box]
        {| Gam, loop +- e => (q, cs, ts) |\quad
         | q' = attach pos 1 (proj (iter, item1:iter) loop) |}
        {| Gam, loop +- box e => (q', {item1}, {item1 ->  (q, cs, ts)}) |} \\
    \infrule[ac-unBox]
        {| Gam, loop +- e => (q, {item1}, ts) |\quad
         | (q', cs', ts') = lookup item1 ts |\\
         | q'' = proj (iter:iter', pos, ln cs')(join (item1':iter) (proj (iter':iter, item1':item1) q) q')|}
        {| Gam, loop +- unbox e => (q'', cs', ts') |}
    \end{infrules}
\begin{code}
tyToCol :: Type -> Int -> Columns

mapForward :: Gam -> Query -> Cs -> (Query, Query, Query, Query, Gam)
mapForward Gam q cs =  let  qv'    = rownum inner (iter, pos) q
                            qv     = proj (iter:inner, pos:pos', ln cs) (attach pos' 1 qv')
                            mapv   = proj (outer:iter, inner, pos':pos) qv'
                            loopv  = proj (iter:inner) qv'
                            Gamv   = map (\(x, (q, cs, ts)) -> (x, (proj (iter:inner, pos, ln cs) (join (iter:outer) q mapv), cs ts))) Gam
                        in  (qv', qv, mapv, loopv, Gamv)
                        
merge qo ts1' ts2' =  {  x1 +-> (q', cs1, merge qr ts1 ts2)  
                      |  x1 +-> (q1, cs1, ts1) elem ts1'
                      ,  x2 +-> (q2, cs2, ts2) elem ts2'
                      ,  x1 == x2 
                      ,  let  ks    = keys ts1
                              cols  = ln cs1
                              qo'   = join (ord, old:iter) ((proj (ord, iterR:iter', old:itemx) qo)) ((union (attach ord 1 q1) (attach ord 2 q2)))
                              q     = rownum iter' (iter, ord, pos) (proj (iter, ord, pos, cols) qo')
                              qr    = proj (iter', ord, cols ) q
                              q'    = proj (iter:iterR, pos, cols \\ ks, ks:iter') q}
\end{code}

Optimized lists, these rules can replace the ac-Cons rule from the previous section.
ac-Cons1 and ac-ConsNil1 have the same signature as ac-Cons. ac-ConsNil1 checks for a singleton list
if so no expensive attach unions and projects have to be carried out.
ac-Cons1 adds an extra environment element to the for transforming e2, this optimized version carries
out the rank operator. The rules that fit, ac-Cons2, and ac-ConsNil2 only do the attach but do not perform the
rank, or the projection. These will only be done by the first element of the list.

\begin{code}
merges n ts1' ts2'   =  {  x1 -> (q, cs1, merges n ts1 ts2)
                        |  x1 -> (q1, cs1, ts1) elem ts1'
                        ,  x2 -> (q2, cs2, ts2) elem ts2'
                        ,  x1 == x2
                        ,  let  q = union (attach ord n q1) q2 }
mergen n ts1'        =  {  x1 -> (q, cs1, mergen n ts1)
                        |  x1 -> (q1, cs1, ts1) elem ts1'
                        ,  let  q = attach ord n q1 }
mergef qo ts1' ts2'  =  {  x1 -> (q', cs1, mergef qr ts1 ts2)
                        |  x1 -> (q1, cs1, ts1) elem ts1'
                        ,  x2 -> (q2, cs2, ts2) elem ts2'
                        ,  x1 == x2
                        ,  let  ks    = keys ts1
                                cols  = ln cs1
                                qo'   = join (ord, old:iter) ((proj (ord, iterR:iter', old:itemx) qo)) ((rownum iter' (iter, ord, pos) (union (attach ord 1 q1) q2)))
                                q     = proj (iter, ord, pos, cols) qo'
                                qr    = proj (iter', ord, cols) q
                                q'    = proj (iter:iterR, pos, cols\\ks, ks:iter') q}
\end{code}

\begin{infrules}
    \infrule[ac-Cons1]
            {| Gam, loop +- e1 => (q1, cs1, empty) |\quad
             | Gam, loop, 2 +- e2 => (q2, cs2, empty)|\\
             | q' = rownum iter' (iter,ord,pos) (rank pos' (<ord, pos>) (union (attach ord 1 q1) q2))| \\
             | q = proj (iter, pos:pos', cols\\ks, ks:iter') q'|}
            {| Gam, loop +- Cons e1 e2 => (q, cs1, mergef q' ts1 ts2)|}\\
    \infrule[ac-ConsNil1]
            {| Gam, loop +- e1 => (q1, cs1, empty)|}
            {| Gam, loop +- Cons e1 Nil => (q1, cs1, empty)|}\\
    \infrule[ac-Cons2]
            {| Gam, loop +- e1 => (q1, cs1, empty) |\quad
             | Gam, loop, i + 1 +- e2 => (q2, cs2, empty) |\\
             | q = union (attach ord i q1) q2 |}
            {| Gam, loop, i +- Cons e1 e2 => (q, cs1, merges i ts1 ts2) |}\\
    \infrule[ac-ConsNil2]
            {| Gam, loop +- e1 => (q1, cs1, empty)|\quad
             | q = (attach ord i q1) |}
            {| Gam, loop, i +- Cons e1 Nil => (q, cs1, mergen n ts1) |}
\end{infrules}