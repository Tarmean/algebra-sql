\section{Type System}

\subsection{Non syntax directed}

Please note the type rules for operators do not fit entirely as expected but in the near future they will change into something correct
\begin{infrules}
     \infrule[t-int]%
        {| |}%
        {|Gam, C +- n : TyInt|}%
    \infrule[t-float]
        {| |}
        {|Gam, C +- f : TyFloat|}
    \infrule[t-string]
        {| |}
        {|Gam, C +- s : TyString |}
    \\
    \infrule[t-true]
        {| |}
        {|Gam, C +- True : TyBool|}
    \infrule[t-bool]
        {| |}
        {|Gam, C +- False : TyBool|}
    \\
    \infrule[t-var]
        {|sig = Gam(x)|}
        {|Gam, C +- x : sig|}
    \infrule[t-let]
        {| Gam, C +- | | e1 : t1|\quad%
         | Gam[x +-> t1], C +- | | e2 : t2 |}
        {| Gam, C +- let x = e1 in e2 : t2|}
    \\
    \infrule[t-Bin-op]
        {| Gam, C +- | |e1 : top1 |\quad%
         | Gam, C +- | |e2 : top2 |}
        {| Gam, C +- | |e1 op e2 : top|}
    \infrule[t-Un-op]
        {| Gam, C +- | |e1 : top1 |}
        {| Gam, C +- u e1 : top |}
    \\
    \infrule[t-if]
        {| Gam, C +- | | e1 : TyBool |\quad%
         | Gam, C +- | | e2 : t|\quad%
         | Gam, C +- | | e3 : t|}
        {| Gam, C +- if e1 then e2 else e3 : t |}
    \\
    \infrule[t-app]
        {| Gam, C +- | | e1 | | : t2 -> ... -> tn -> t0|\quad%
         | Gam, C +-- | | e2 : t2|\quad%
         | ... |\quad%
         | Gam, C +-- | | en : tn|}
        {| Gam, C +- | | e1 |~|e2 |~| ... |~| en : t0|}
    \\
    \infrule[t-cons]
        {| Gam, C +- | | e1 : t|\quad
         | Gam, C +- | | e2 : [t] |}
        {| Gam, C +- Cons e1 e2 : [t]|}
    \infrule[t-nil]
        {| |}
        {|Gam, C +- Nil : [t]|}
    \\
    \infrule[t-elem]
        {| Gam, C +- e : {i :: t} |}
        {| Gam, C +- e.i : t|}
    \\
    \infrule[t-table]
        {| |}
        {| Gam, C +- table R (col1 t1, ..., coln tn) with keys (k1, ..., kn) : [{col1 :: t1, ..., coln :: tn}] |}
    \\
    \infrule[t-rec]
        {| Gam, C +- | |e1 : t1 |\quad%
         | ... |\quad%
         | Gam, C +- | |en : tn |}
        {|Gam, C +- {x1 = e1, ..., xn = en} : {x1 :: t1, ..., xn :: tn}|}
\end{infrules}

Typing arguments:

\begin{infrules}
    \infrule[arg-expr]
        {| Gam, C +- e : t |}
        {| Gam, C +-- e : t|}
    \infrule[arg-abstr]
        {| Gam[x1 +-> t1, ..., xn +-> tn], C +- e : t0|}
        {| Gam, C +- (x1, ..., xn) -> e : t1 -> ... -> tn -> t0|}
\end{infrules}

Instantiation and generalisation and record weakening
\begin{infrules}
    \infrule[t-qual]
        {|Gam, C union {pi} +- e : sig|}
        {|Gam, C +- e : pi => sig |}
    \infrule[t-res]
        {|Gam, C +- e : pi => sig|\quad |C +- pi|}
        {|Gam, C +- e : sig|}
    \\
    \infrule[t-gen]
        {| Gam, C +- e : sig|\quad%
         | a NotIn ftv(Gam) |}
        {| Gam, C +- e : forall a. sig|}
    \infrule[t-ins]
        {| Gam, C +- e : forall a. sig|}
        {| Gam, C +- e : [a +-> t] sig|}
    \\
    \infrule[t-RecRes]
        {|Gam, C +- e : {x1 :: t1, ..., xn :: tn}|}
        {|Gam, C union {r <: {x1 :: t1}, ..., r <: {xn :: tn}} +- e : r|}
    \\
    \infrule[t-RecQual]
        {|Gam, C union {r <: {x1 :: t1, ..., xn :: tn}} +- e : r|}
        {|Gam, C +- e : {x1 :: t1, ..., xn :: tn} |}
\end{infrules}


\subsection{Syntax directed}

Instantiation is merged into variable access.
Generalization into let bindings and weakening into elem access.

We introduce the following helper functions:

\begin{figure}[!h]
\begin{boxedminipage}{\columnwidth}
    \begin{code}
        ftv(TyInt)                      =  empty
        ftv(TyFloat)                    =  empty
        ftv(TyString)                   =  empty
        ftv(TyBool)                     =  empty
        ftv([t])                        =  ftv(t)
        ftv({l1 :: t1, ..., ln :: tn})  =  ftv(t1) `union` ... `union` ftv(tn)
        ftv(t1 -> t2)                   =  ftv(t1) `union` ftv(t2)
        ftv(a)                          =  {a}
    \end{code}
  \end{boxedminipage}
  \caption{Free type variables in types}
\end{figure}

\begin{figure}[!h]
\begin{boxedminipage}{\columnwidth}
    \begin{code}
        ftv(forall a. sig)  = ftv(sig)\\{a}
    \end{code}
  \end{boxedminipage}
  \caption{Free type variables in type schemes}
\end{figure}

\begin{figure}[!h]
\begin{boxedminipage}{\columnwidth}
    \begin{code}
        inst :: TyScheme -> Ty
        inst (forall a1 ... an. qt) = [a1 +-> a1']...[an +-> an'] qt
                where a1' ... an' are fresh
            
        gen :: TyEnv -> CEnv -> Ty -> (TyScheme, CEnv)
        gen(Gam, t) = forall a1 ... an. qt
                where {a1 ... an} = ftv(qt) - ftv(Gam)
    \end{code}
  \end{boxedminipage}
  \caption{Instantiation and Generalization functions}
\end{figure}

\begin{infrules}
     \infrule[t-int]%
        {| |}%
        {|Gam, C +- n : TyInt|}%
    \infrule[t-float]
        {| |}
        {|Gam, C +- f : TyFloat|}
    \infrule[t-string]
        {| |}
        {|Gam, C +- s : TyString |}
    \\
    \infrule[t-true]
        {| |}
        {|Gam, C +- True : TyBool|}
    \infrule[t-bool]
        {| |}
        {|Gam, C +- False : TyBool|}
    \\
    \infrule[t-var]
        {|{pi1, ..., pin} => t = inst(Gam(x))|}
        {|Gam, C union {pi1, ..., pin} +- x : t|}
    \\
    \infrule[t-let]
        {| Gam, C' +- | | e1 : t1|\quad%
         | (sig, C'') = gen(Gam, C, t1) |\quad%
         | Gam[x +-> sig], C union C'' +- | | e2 : t2 |}
        {| Gam C union C'' +- let x = e1 in e2 : t2|}
    \\
    \infrule[t-Bin-op]
        {| Gam, C +- | |e1 : top1 |\quad%
         | Gam, C +- | |e2 : top2 |}
        {| Gam, C +- | |e1 op e2 : top|}
    \infrule[t-Un-op]
        {| Gam, C +- | |e1 : top1 |}
        {| Gam, C +- u e1 : top |}
    \\
    \infrule[t-if]
        {| Gam, C +- | | e1 : TyBool |\quad%
         | Gam, C +- | | e2 : t|\quad%
         | Gam, C +- | | e3 : t|}
        {| Gam, C +- if e1 then e2 else e3 : t |}
    \\
    \infrule[t-app]
        {| Gam, C +- | | e1 | | : t2 -> ... -> tn -> t0|\quad%
         | Gam, C +-- | | e2 : t2|\quad%
         | ... |\quad%
         | Gam, C +-- | | en : tn|}
        {| Gam, C +- | | e1 |~|e2 |~| ... |~| en : t0|}
    \\
    \infrule[t-cons]
        {| Gam, C +- | | e1 : t|\quad
         | Gam, C +- | | e2 : [t] |}
        {| Gam, C +- Cons e1 e2 : [t]|}
    \infrule[t-nil]
        {| |}
        {|Gam, C +- Nil : [t]|}
    \\
    \infrule[t-elem]
        {| Gam, C +- e : r |\quad%
         | r <: {i :: t} In C|}
        {| Gam, C +- e.i : t|}
    \\
    \infrule[t-table]
        {| |}
        {| Gam, C union {r <: col1 :: t1, ..., r <: coln :: tn} +- table R (col1 t1, ..., coln tn) with keys (k1, ..., kn) : [r] |}
    \\
    \infrule[t-rec]
        {| Gam, C +- | |e1 : t1 |\quad%
         | ... |\quad%
         | Gam, C +- | |en : tn |}
        {|Gam, C union {r <: x1 :: t1, ..., r <: xn :: tn} +- {x1 = e1, ..., xn = en} : r|}
\end{infrules}

\begin{infrules}
    \infrule[arg-expr]
        {| Gam, C +- e : t |}
        {| Gam, C +-- e : t|}
    \infrule[arg-abstr]
        {| Gam[x1 +-> t1, ..., xn +-> tn], C +- e : t0|}
        {| Gam, C +- (x1, ..., xn) -> e : t1 -> ... -> tn -> t0|}
\end{infrules}