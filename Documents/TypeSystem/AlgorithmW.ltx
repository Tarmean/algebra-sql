\section{Algorithm $\mathcal{W}$}

The algorithm use substitutions to recover type information. A substitution is a function from a type to a type and can replace type variables inside a type by a different type. Substitutions can be composed,| subst1 . subst2 |,  the empty substitution is the identity function, |id|, and when applied they are applied recursively on a type. A substitution has the following form |[a -> t]|, if the type it is applied to is anything else then type variable a it is not applied, the rest of the composed substitution will however be applied if possible. Substitutions are idempotent so |subst (subst t) = subst t|.

\begin{code}
 W(Gam, n)                 =  (TyInt, id, empty)
 W(Gam, f)                 =  (TyFloat, id, empty)
 W(Gam, s)                 =  (TyString, id, empty)
 W(Gam, True)              =  (TyBool, id, empty)
 W(Gam, False)             =  (TyBool, id, empty) 
 W(Gam, x)                 =  let  C => t = inst(Gam(x))
                               in  (t, id, C)
 W(Gam, let x = e1 in e2)  =  let  (t1, subst1, c1) = W(Gam, e1)
                                   (c1', sig) = gen(Gam, c1, t1)
                                   (t2, subst2, c2) = W(subst1 Gam[x +-> sig], e2)
                               in  (t2, subst2 . subst1, subst c1' `union` c2)
 W(Gam, e1 op e2)          =  let  top1 -> top2 -> top = Gam(op)
                                   (t1, subst1, c1) = W(Gam, e1)
                                   (t2, subst2, c2) = W(subst1 Gam, e2)
                                   subst3 = U(subst2 t1, t1op)
                                   subst4 = U(subst3 t2, t2op)
                                   subst = subst4 . subst3 . subst2 . subst1
                               in  (trop, subst, subst c1 `union` c2)
 W(Gam, u e)               =  let  top1 -> top = Gam(u)
                                   (t, subst1, c1) = W(Gam, e)
                                   subst2 = U(t, top1)
                                   subst = subst2 . subst1
                               in  (top, subst, subst c1)
 W(Gam, e0 e1 ... en)      =  let  ar be fresh
                                   (t0, subst0, c0) = W(Gam, e0)
                                   (t1, subst1, c1) = W(subst0 Gam, e1)
                                   ...
                                   (tn, substn, cn) = W(substn1 . ... . subst0 Gam, en)
                                   substm = U(subst1 . ... . substn t0, (subst2 . ... . substn) t1 -> ... -> tn -> ar)
                                   subst = substm . substn . ... . subst0
                               in  (substm ar, subst, subst (c0 `union` c1 `union` ... `union` cn))
\end{code}
\begin{code}
 W(Gam, Nil)               =  let  a be fresh
                               in  (List a, id, empty)
 W(Gam, Cons e1 e2)        =  let  (t1, subst1, c1)    = W(Gam, e1)
                                   (t2, subst2, c2)    = W(subst1 Gam, e2)
                                   subst3              = U(t2, [(subst2 t1)])
                               in  (subst3 t2, subst3 . subst2 . subst1, subst3 . subst2 (c1 `union` c2))
 W(Gam, e.i)               =  let  a be fresh
                                   (t1, subst, c) = W(Gam, e)
                                   (t', c') = case t1 of
                                                {_}       -> (lookup i t1 c, c) 
                                                otherwise -> (a1, {a1 <: i::a} `union` c)
                               in  (tr, subst, c')
 W(Gam, table r (col1 t1, ..., coln tn) with keys (k1, ..., kn))
                           =  ([{col1 :: t1, ..., coln :: tn}], id, c)
 W(Gam, {x1 = e1, ..., xn = en})
                           =  let  (t1, subst1, c1) = W(Gam, e1)
                                   ...
                                   (tn, substn, cn) = W(Gam, en)
                                   subst = substn . ... . subst1
                               in  (subst {x1 :: t1, ..., xn :: tn}, c1 `union` ... `union` cn) 
 W(Gam, if e1 then e2 else e3)
                           =  let  (t1, subst1, c1) = W(Gam, e1)
                                   (t2, subst2, c2) = W(subst1 Gam, e2)
                                   (t3, subst3, c3) = W(subst2 . subst1 Gam, e2)
                                   subst4 = U(subst3 . subst2 t1, TyBool)
                                   subst5 = U(subst4 . subst3 t2, subst4 t3)
                                   subst = subst5 . subst4 . subst3 . subst2 . subst1
                               in  (subst5 . subst4 t3, subst, subst (c1 `union` c2 `union` c3))
 W(Gam, \(x1,..., xn) -> e)
                           =  let  a1 ... an be fresh
                                   (t, subst , c) = W(Gam[x1 +-> a1, ..., xn +-> an], e)
                               in  (subst (a1 -> ... -> an -> t), subst, c)    
\end{code}