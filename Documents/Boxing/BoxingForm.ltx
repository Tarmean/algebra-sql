\section{Boxing}
             
The boxing rules follow the following pattern: | C,Gam, Ome +- e => e' :: psi |. Which is read as: Under the context |C| type environment |Gam| and boxing environment |Ome| expression |e| is transformed into expression |e'| with boxing boxing type |psi|. |Gam| contains all primitive types.

We define a formula that takes care of transforming an expression into a boxed, or unboxed expressions.

For the sake of readability we ommitted several sanity checks, we will however describe them here informally. Each rule is defined as |C, Gam, Ome +- e => e' :: psi|. There is a relation between the context |C|, which tells about the expected value and the returned boxing type |psi|. The head of the context |C| has to be equal to the result |psi|. If C is empty any |psi| will do.

The boxing language:

\begin{syntaxdefs}
    \syntaxdef{|psi|}
        \alt{|atom|}
        \alt{|list|}
        \alt{|psi -> psi|}
\end{syntaxdefs}  

We define a type conversion function from regular types to boxing types:

\begin{code}
  trans :: t -> psi  
  trans (TyList _) = list
  trans (t1 -> t2) = trans t1 -> trans t2
  trans _ = atom
\end{code}

\begin{code}
         Box list atom e = box e
         Box atom list e = unBox e
         Box list list e = e
         Box atom atom e = e
\end{code}

\begin{infrules} 
    \infrule[box-int]
            {| |}
            {| C, Gam, Ome +- i => i :: atom |}
    \infrule[box-float]
            {| |}
            {| C, Gam, Ome +- f => f :: atom |}
    \infrule[box-bool]
            {| |}
            {| C, Gam, Ome +- b => b :: atom |}\\    
    \infrule[box-string]
            {| |}
            {| C, Gam, Ome +- s => s :: atom |}
    \infrule[box-Nil]
            {| |}
            {| C, Gam, Ome +- Nil => Nil :: list |}\\
    \infrule[box-Cons]
            {| [], Gam, Ome +- e1 => e1' :: psi |\quad%
             | C, Gam, Ome +- e2 => e2' :: psi2 |}
            {| C, Gam, Ome +- Cons e1 e2 => Cons (Box psi atom e1') (Box psi2 list e2') :: list|}
    \infrule[box-var-prim]
            {| Gam x = sig |\quad%
             | psi = trans(inst(sig)) |}
            {| C, Gam, Ome +- x => x :: psi |}\\ 
    \infrule[box-var]
            {|Ome x = psi|}
            {|C, Gam, Ome +- x => x :: psi|}
    \infrule[box-app]
            {| C, Gam, Ome +- e1 => e1' :: psi1 -> psi2 |\quad%
             | C[psi1], Gam, Ome +- e2 => e2' :: psi0 |}
            {| C, Gam, Ome +- e1 e2 => e1' (Box psi0 psi1 e2') :: psi2|}\\
    \infrule[box-let]
            {| C, Gam, Ome +- e1 => e1' :: psi1 |\quad%
             | C, Gam, Ome[x +-> psi1] +- e2 => e2' :: psi2 |}
            {| C, Gam, Ome +- let x = e1 in e2 => let x = e1' in e2' :: psi2|}\\
    \infrule[box-op]
            {| Gam `op` = psi1 -> psi2 -> psi3|\quad%
             | [], Gam, Ome +- e1 => e1' :: psi1' |\quad%
             | [], Gam, Ome +- e2 => e2' :: psi2' |}
            {| C, Gam, Ome +- e1 `op` e2 => (Box psi1' psi1 e1') `op` (Box psi2' psi2 e2') :: psi3 |}\\
    \infrule[box-unop]
            {| Gam u = psi1 -> psi2 |\quad%
             | [], Gam, Ome +- e1 => e1' :: psi1'|}
            {| C, Gam, Ome +- u e1 :: u (Box psi1' psi1 e1') :: psi1 |}\\   
    \infrule[box-if]
            {| [], Gam, Ome +- e1 => e1' :: psi1 |\quad%
             | C, Gam, Ome +- e2 => e2' :: psi2 |\quad%
             | C, Gam, Ome +- e3 => e3' :: psi2 |}
            {| C, Gam, Ome +- if e1 then e2 else e3 => if (Box psi1 atom e1') then e2' else e3' :: psi2 |}\\
    \infrule[box-if-alt]
            {| [], Gam, Ome +- e1 => e1' :: psi1 |\quad%
             | [], Gam, Ome +- e2 => e2' :: psi2 |\quad%
             | [], Gam, Ome +- e3 => e3' :: psi3 |}
            {| C[psi], Gam, Ome +- if e1 then e2 else e3 => if (Box psi1 atom e1') then (Box psi2 psi) else (Box psi3 psi) :: psi|}\\
    \infrule[box-elem]
            {| [], Gam, Ome +- e => e' :: psi1 |}
            {| C, Gam, Ome +- e.i => (Box psi1 atom e').i :: atom|}
    \infrule[box-table]
            {| |}
            {| C, Gam, Ome +- table R cs with keys ks => table R cs with keys ks :: list |}\\
    \infrule[box-rec]
            {| [], Gam, Ome +- e1 => e1' :: psi1 |\quad%
             | ... |\quad%
             | [], Gam, Ome +- en => en' :: nsi1 |}
            {| C, Gam, Ome +- {x1 = e1, ..., xn = en} => {x1 = (Box psi1 atom e1'), ...,xn = (Box psin atom en')} :: atom|}\\
    \infrule[box-lambda]
            {| C[psi2], Gam, Ome[x +-> psi1] +- e => e' :: psi2|}
            {| C[psi1 -> psi2], Gam, Ome +- (\x -> e) => (\x -> e') :: psi1 -> psi2|}
\end{infrules}           

In the original implementation there doesn't seem to be a check that both branches of if ... then ... else are equal. Therefor it is not possible to determine what sort of boxing type the if then else construct as a whole has. Furthermore it is not clear whether the conditional should be required to be of the sort atom.
The handling of a lambda seems to be quite ad-hoc as well, it could very well be that the lambda would be better of accepting lists as arguments. 