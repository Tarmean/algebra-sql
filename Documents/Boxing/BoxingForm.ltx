\section{Boxing}
             
The boxing rules follow the following pattern: | Gam +- e => e' :: sig |. Which is read as under environment |Gam| expression |e| is transformed into expression |e'| with boxing type |sig|.

We define a formula that takes care of transforming an expression into a boxed, or unboxed expressions.

\begin{code}
         Box list atom e = box e
         Box atom list e = unBox e
         Box list list e = e
         Box atom atom e = e
\end{code}


\begin{infrules} 
    \infrule[box-int]
            {| |}
            {| Gam +- i => i :: atom |}
    \infrule[box-float]
            {| |}
            {| Gam +- f => f :: atom |}
    \infrule[box-bool]
            {| |}
            {| Gam +- b => b :: atom |}\\    
    \infrule[box-string]
            {| |}
            {| Gam +- s => s :: atom |}
    \infrule[box-Nil]
            {| |}
            {| Gam +- Nil => Nil :: list |}\\
    \infrule[box-Cons]
            {| Gam +- e1 => e1' :: sig |\quad%
             | Gam +- e2 => e2' :: sig2 |}
            {| Gam +- Cons e1 e2 => Cons (Box sig atom e1') (Box sig2 list e2') :: list|}
    \infrule[box-var]
            {| Gam x = sig |}
            {| Gam +- x => x :: sig |}\\
    \infrule[box-let]
            {| Gam +- e1 => e1' :: sig1 |\quad%
             | Gam[x +-> sig1] +- e2 => e2' :: sig2 |}
            {| Gam +- let x = e1 in e2 => let x = e1' in e2' :: sig2|}
    \infrule[box-app]
            {| Gam +- e1 => e1' :: sig1 -> sig2 |\quad%
             | Gam +- e2 => e2' :: sig0 |}
            {| Gam +- e1 e2 => e1' (Box sig0 sig1 e2') :: sig2|}\\
    \infrule[box-op]
            {| Gam `op` = sig0 -> sig1 -> sig2|\quad%
             | Gam +- e1 => e1' :: sig1' |\quad%
             | Gam +- e2 => e2' :: sig2' |}
            {| Gam +- e1 `op` e2 => (Box sig1' sig0 e1') `op` (Box sig2' sig1 e2') :: sig2 |}
    \infrule[box-unop]
            {| Gam u = sig0 -> sig1 |\quad%
             | Gam +- e1 => e1' :: sig1'|}
            {| Gam +- u e1 :: u (Box sig1' sig0 e1') :: sig1 |}\\   
    \infrule[box-if]
            {| Gam +- e1 => e1' :: sig1 |\quad%
             | Gam +- e2 => e2' :: sig2 |\quad%
             | Gam +- e3 => e3' :: sig2 |}
            {| Gam +- if e1 then e2 else e3 => if (Box sig1 atom e1') then e2' else e3' :: sig2 |}\\
    \infrule[box-elem]
            {| Gam +- e => e' :: sig1 |}
            {| Gam +- e.i => (Box sig1 atom e').i :: atom|}
    \infrule[box-table]
            {| |}
            {| Gam +- table R cs with keys ks => table R cs with keys ks :: list |}\\
    \infrule[box-rec]
            {| Gam +- e1 => e1' :: sig1 |\quad%
             | ... |\quad%
             | Gam +- en => en' :: sign |}
            {| Gam +- {x1 = e1, ..., xn = en} => {x1 = (Box sig1 atom e1'), xn = (Box sign atom en')}|}
    \infrule[box-lambda]
            {| Gam[x +-> atom] +- e => e' :: phi|}
            {| Gam +- (\x -> e) => (\x -> e') :: atom -> phi|}
\end{infrules}           

In the original implementation there doesn't seem to be a check that both branches of if ... then ... else are equal. Therefor it is not possible to determine what sort of boxing type the if then else construct as a whole has. Furthermore it is not clear whether the conditional should be required to be of the sort atom.
The handling of a lambda seems to be quite ad-hoc as well, it could very well be that the lambda would be better of accepting lists as arguments. 