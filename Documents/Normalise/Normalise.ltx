\section{Ferry Front language normalisation}

The |sort| function orders record fields in alphabetical order

\begin{code}
 norm c               =  c
 norm (e1,..., en)    =  ( norm(e1) , ..., norm(e2) )
 norm {b1,..., bn}    =  sort {normb b1 , ..., normb bn }
 norm [e1, ..., en]   =  [norm e1 , ..., norm en]
 (norm (table T (col1, ..., coln) with keys (k1, ..., k2)))
                      =  table T (sort ((col1, ..., coln))) with keys (k1, ..., k2)
 norm(e.p)            =  norm(e).p
 norm(e.n)            =  norm(e).n
 norm(e1(e2))         =  norm(lookup e2 e1)
 norm(e1 op e2)       =  norm e1 `op` norm e2
 norm(op e1)          =  `op` norm e1
 norm (lookup ek el)  =  norm ((single (filter (v -> v.1 == ek) el)).2)
 norm (e1 arg1 ... argn) 
                      =  norm e1 (normp arg1) ... normp argn
 norm (let x1 = e1, x2 = e2, ..., xn = en in er)
                      =  norm (let x1 = e1 in let x2 = e2 in .... let xn = en in er)
 norm (let x = e1 in e2)
                      =  let x = norm e1 in norm e2
 norm ((e))           =  norm e
 norm (if e1 then e2 else e3)
                      =  if norm e1 then norm e2 else norm e3
 norm (relationship from one e1 to one e2 by k1 eq k2)
                      =  norm (map (v1 -> (v1, single (filter (v2 -> compgen (v1, v2, k1, k2)) e2))) e1)
 norm (relationship from one e1 to many e2 by k1 eq k2)
                      =  norm (map (v1 -> (v1, filter (v2 -> compgen (v1, v2, k1, k2))e2)) e1)
 norm (for (v1, ..., vn) in e1, (x1, ... xm) in e2 rest)
                      =  norm  (for * in concatMap (p1 -> e2) (((v1,...,vn),(x1,...,xm)) -> {v1,...,vn,x1,...,xm}) e1 
                               [v1 +-> *.v1,..., vn +-> *.vn, x1 +-> *.x1,..., xm +-> *.xm] rest)
 norm (for p1 in e1 for p2 in e2 rest)
                      =  norm (for p1 in e1, p2 in e2 rest)
 norm (for p1 in e1 where e2 rest)
                      =  norm (for p1 in filter (p1 -> e2) e1 rest)
 norm (for p1 in e let v1 = e1,..., vn = en let vn1 =en1, ..., vm = em rest)
                      =  norm (for p1 in e let v1 = e1, ..., vn, vn1 = en1, ..., vm = em rest)
 norm (for (x1, ..., xm) in e let v1 = e1, ..., vn = en rest)
                      =  norm (for * in map ((x1, ..., xm) -> {x1, ..., xm, v1 = e1, ..., vn = en}) e 
                         [x1 +-> *.x1, ..., xn +-> *.xn, v1 +-> *.v1, ..., vn +-> *.vn] rest)
 norm (for p1 in e1 order by ..., e2, ... rest)
                      =  norm (for p1 in e1 order by ..., e2 ascending, ... rest)
 norm (for p in e order by e1 od1, ..., en odn rest)
                      =  norm (for p in ordt odn (p -> en)(...(ord0 od1 (p -> e1) e)) rest)
 norm (for p1 in e1 group [ev] (by|with) ek1, ..., ekn [into p2] rest)
                      =  norm  (for p1 in e1 group [ev] (by|with) (ek1, ..., ekn) [into p2] rest)
\end{code}

\begin{code}
 norm (for p in e group (by|with) ek rest)
                      =  norm (for p in (groupBy|groupWith) (* -> *) (p -> ek) e rest)
 norm (for p in e group ev (by|with) ek rest)
                      =  norm (for p in e (groupBy|groupWith) (p -> ev) (p -> ek) e rest)
 norm (for p1 in e group (by|with) ek into p2 rest)
                      =  norm (for p2 in (groupBy|groupWith) (* -> *) (p1 -> ek) e rest)
 norm (for p1 in e group ev (by|with) ek into p2 rest)
                      =  norm (for p2 in (groupBy|groupWith) (p1 -> ev) (p1 -> ek) e rest)
 norm (for p in e return p)
                      =  norm e
 norm (for p in e1 return e2)
                      =  norm (map (p -> e2) e1)
 norm (for p1 in e1 return e2 into p2 rest)
                      =  norm (for p2 in (for p1 in e1 return e2) rest)
\end{code}

\begin{code}
    normb(v = e)  =  v = norm(e)
    normb(v)      =  v = v
    normb(e.v)    =  v = norm(e.v)
\end{code}

\begin{code}
    normp e           =  norm e
    normp ((x11, ..., x1n), ..., (xm1, ..., xmn) -> e)  =  (s1, ..., sm -> norm 
                                                           [x11 +-> s1.1, ..., xn1 +-> s1.n, ...,
                                                           xm1 +-> sm.1, ..., xmn +-> sm.n] e)
\end{code}

\begin{code}
    compgen (v1, v2, (c1, ..., cn), (d1, ..., dn)) = v1.c1 == v2.d1 && ... && v1.cn == v2.dn
\end{code}

\begin{code}
    ord0 ascending   =  orderBy
    ord0 descending  =  orderByDescending
    ordt ascending   =  thenBy
    ordt descending  =  thenByDescending
\end{code}