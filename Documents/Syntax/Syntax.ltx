\section{Ferry Language Syntax}

\begin{sets}%
  \declareset{Types\enspace,}{|Types|}{|t|}%
  \declareset{Identifiers\enspace,}{|Ident|}{|id|}%
  \declareset{Constants\enspace,}{|Const|}{|c|}%
  \declareset{Natural numbers\enspace,}{|Nat|}{|n|}%
  \declareset{Integers\enspace,}{|Ints|}{|i|}%
  \declareset{Floats\enspace,}{|Floats|}{|fl|}%
  \declareset{Strings \enspace,}{|CStrings|}{|s|}%
  \declareset{booleans\enspace,}{|Bools|}{|boo|}%
  \declareset{expressions \enspace,}{|Exp|}{|e|}%
  \declareset{variables\enspace,}{|Var|}{|x|}%
  \declareset{binary operators\enspace,}{|Op|}{|op|}%
  \declareset{Orderings\enspace,}{|Ord|}{|o|}%
  \declareset{Cardinality\enspace,}{|Car|}{|car|}%
  \declareset{Primitive functions \enspace,}{|Prim|}{|f|}%
  \declareset{Patterns\enspace,}{|Pat|}{|p|}%
  \declareset{Column names\enspace,}{|Columns|}{|col|}%
  \declareset{Table names}{|Tables|}{|R|}
\end{sets}

Notational conventions:

We write | [e] | to denote an option, | {e} | to denote zero or more repetitions.
We write (e) to denote a grouping
\begin{syntaxdefs}%
	\syntaxdef{|ordering|}
		\alt{|ascending|}
		\alt{|descending|}
	\syntaxdef{|cardinality|}
		\alt{|many|}
		\alt{|one|}
	\syntaxdef{|op|}
		\alt{|+|} 
		\alt{|-|}
		\alt{|/|}
		\alt{|*|}
		\alt{|%|} 
		\alt{|...|} 
	\syntaxdef{|c|}
		\alt{|i|}
		\alt{|fl|}
		\alt{|boo|}
		\alt{|"s"|}
	\syntaxdef{|i|}
		\alt{|...|}
		\alt{|-2|}
		\alt{|-1|}
		\alt{|0|}
		\alt{|1|}
		\alt{|2|}
		\alt{|...|}
	\syntaxdef{|n|}
			\alt{|1|}
			\alt{|2|}
			\alt{|...|}
	\syntaxdef{|boo|}
		\alt{|True|}
		\alt{|False|}
	\syntaxdef{|x|}
		\alt{|id|}
	\syntaxdef{|pattern|}
		\alt{|x|}
		\alt{|PAREN(x1, ...,xn)| \quad |where n >= 2| }
	\syntaxdef{|l|}
		\alt{|n|}
		\alt{|x|}
	\syntaxdef{|k|}
		\alt{|PAREN(col1, ..., coln)| \quad |where n >= 1|}
  	\syntaxdef{|arg|}
  	    \alt{|atom|}
  	    \alt{|(pat -> e)|}
  	\syntaxdef{|atom|}
  	    \alt{|c|}
  		\alt{|x|}
		\\
		\alt{|PAREN(e1, ..., en)| \quad |where n >= 2|}
		\\
		\alt{|PAREN(e)|}
		\\
		\alt{|CURL(x1 = e1, ..., xn = en)| \quad |where n >= 1|}
		\\
		\alt{|SQBR(e1, ..., en)| \quad |where n >= 0|}
		\\
		\alt{|atom <.> l|}
		\alt{|atom| |CURL(e)|}
  	\syntaxdef{|e|}
		\alt{|f arg1 ... argn|\quad |where n >= 1|}
		\\
		\alt{|e1 op e2|}
		\alt{|if e0 then e1 else e2|}
		\\
		\alt{|let x1 = e1, ..., xn = en in e| \quad |where n >= 1|}
		\\
		\alt{|table R| |PAREN(col1 t1, ..., coln tn) with keys| |PAREN(k1, ..., km) | \quad |where n >= 1 & m >= 1|}
		\\
		\alt{|relationship from cardinality e1 to cardinality e2 by k1 eq k2|}
		\\
		\alt{|ferryCompr|}
		\alt{|atom|}
\end{syntaxdefs}

\begin{syntaxdefs}
	\syntaxdef{|ferryCompr|}
		\alt{|forClause {bodyClause} returnClause |}
	\syntaxdef{|forClause|}
		\alt{|for pattern in e {, pattern in e}|}
	\syntaxdef{|bodyClause|}
		\alt{|forClause|}\\
		\alt{|where e|}\\
		\alt{|let x = e {, x = e}|}\\
		\alt{|order by [ordering] e {,[ordering] e}|}\\
		\alt{|groupClause|}
	\syntaxdef{|groupClause|}
		\alt{|group [e] (by || with) e {, en} [into pattern]|}
	\syntaxdef{|returnClause|}
		\alt{|return e [into pat {bodyClause} returnClause]|}
\end{syntaxdefs}


